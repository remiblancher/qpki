name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true

      - name: "[Unit] Run Go Tests"
        run: |
          go test -v -race -json -coverprofile=coverage.out -covermode=atomic ./... 2>&1 | tee test-output.json
          chmod +x scripts/ci/go-test-ctrf.sh
          TOOL_NAME=unit ./scripts/ci/go-test-ctrf.sh < test-output.json > ctrf-unit.json

      - name: "[Unit] Show Coverage"
        run: |
          COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}')
          echo "Total coverage: ${COVERAGE}"

      - name: "[Unit] Check Coverage Threshold"
        run: |
          COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | tr -d '%')
          echo "Coverage: ${COVERAGE}%"
          if (( $(echo "$COVERAGE < 70" | bc -l) )); then
            echo "::error::Coverage ${COVERAGE}% is below 70% minimum threshold"
            exit 1
          fi

      - name: "[Unit] Test Summary"
        if: always()
        run: |
          echo "## Unit Tests" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          COVERAGE=$(go tool cover -func=coverage.out 2>/dev/null | grep total | awk '{print $3}' || echo "N/A")
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Coverage | $COVERAGE |" >> $GITHUB_STEP_SUMMARY
          echo "| Threshold | 70% |" >> $GITHUB_STEP_SUMMARY

      - name: "[Unit] Generate HTML Coverage Report"
        run: go tool cover -html=coverage.out -o coverage.html

      - name: "[Unit] Upload Coverage Report"
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            coverage.out
            coverage.html
          retention-days: 30

      - name: "[Unit] Upload CTRF Report"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ctrf-unit
          path: ctrf-unit.json
          retention-days: 30

      - name: "[Unit] Upload Coverage to Codecov"
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        continue-on-error: true
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage.out
          fail_ci_if_error: false
          verbose: true
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  lint:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true

      - name: "[Unit] Run Golangci-lint"
        uses: golangci/golangci-lint-action@v9
        with:
          version: v2.7.2

  build:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [test, lint]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true

      - name: "[Build] Build Binary"
        run: go build -o qpki ./cmd/qpki

      - name: "[Build] Upload Binary"
        uses: actions/upload-artifact@v4
        with:
          name: qpki-ci-binary
          path: qpki
          retention-days: 1

      - name: "[Smoke] EC PKI Workflow (Manual CSR)"
        run: |
          ./qpki --help
          # Initialize CA
          ./qpki ca init --var cn="Test CA" --profile ec/root-ca --ca-dir /tmp/test-ca
          ./qpki ca export --ca-dir /tmp/test-ca --out /tmp/test-ca/ca.crt
          # Generate key
          ./qpki key gen --algorithm ecdsa-p256 --out /tmp/test-ca/server.key
          # Generate CSR from key
          ./qpki csr gen --key /tmp/test-ca/server.key \
            --cn test.local --dns test.local \
            --out /tmp/test-ca/server.csr
          # Issue certificate from CSR
          ./qpki cert issue --ca-dir /tmp/test-ca --profile ec/tls-server \
            --csr /tmp/test-ca/server.csr --out /tmp/test-ca/server.crt
          # Verify certificate
          ./qpki cert verify /tmp/test-ca/server.crt --ca /tmp/test-ca/ca.crt
          # List certificates
          ./qpki cert list --ca-dir /tmp/test-ca

      - name: "[Smoke] Subordinate CA"
        run: |
          ./qpki ca init --var cn="Issuing CA" --profile ec/issuing-ca --ca-dir /tmp/issuing-ca --parent /tmp/test-ca
          ./qpki ca export --ca-dir /tmp/issuing-ca --out /tmp/issuing-ca/ca.crt
          ./qpki credential enroll --ca-dir /tmp/issuing-ca --cred-dir /tmp/issuing-ca/credentials --profile ec/tls-server \
            --var cn=sub.test.local --var dns_names=sub.test.local
          ./qpki cert list --ca-dir /tmp/issuing-ca

      - name: "[Smoke] Verify: Certificate Chain"
        run: |
          ./qpki inspect /tmp/test-ca/ca.crt
          # Verify subordinate CA chain
          ./qpki cert verify /tmp/issuing-ca/ca.crt --ca /tmp/test-ca/ca.crt
          # Verify certificate from manual CSR workflow
          ./qpki inspect /tmp/test-ca/server.crt
          ./qpki cert verify /tmp/test-ca/server.crt --ca /tmp/test-ca/ca.crt

      - name: "[Smoke] ML-DSA-87 PQC"
        run: |
          # Create PQC CA
          ./qpki ca init --var cn="PQC Test CA" --profile ml/root-ca --ca-dir /tmp/pqc-ca
          ./qpki ca export --ca-dir /tmp/pqc-ca --out /tmp/pqc-ca/ca.crt
          # Issue PQC certificate using credential enroll
          ./qpki credential enroll --ca-dir /tmp/pqc-ca --cred-dir /tmp/pqc-ca/credentials --profile ml/tls-server-sign \
            --var cn=pqc.test.local --var dns_names=pqc.test.local
          # Get credential ID and export certificate
          PQC_CRED_ID=$(ls /tmp/pqc-ca/credentials | head -1)
          ./qpki credential export "${PQC_CRED_ID}" --cred-dir /tmp/pqc-ca/credentials --out /tmp/pqc-ca/pqc-cert.pem
          # Verify with qpki tool (OpenSSL doesn't support PQC yet)
          ./qpki cert verify /tmp/pqc-ca/pqc-cert.pem --ca /tmp/pqc-ca/ca.crt
          ./qpki inspect /tmp/pqc-ca/pqc-cert.pem

      - name: "[Smoke] SLH-DSA-256f PQC"
        run: |
          # Create SLH-DSA CA
          ./qpki ca init --var cn="SLH-DSA Test CA" --profile slh/root-ca --ca-dir /tmp/slhdsa-ca
          ./qpki ca export --ca-dir /tmp/slhdsa-ca --out /tmp/slhdsa-ca/ca.crt
          # Issue SLH-DSA certificate using credential enroll
          ./qpki credential enroll --ca-dir /tmp/slhdsa-ca --cred-dir /tmp/slhdsa-ca/credentials --profile slh/tls-server \
            --var cn=slhdsa.test.local --var dns_names=slhdsa.test.local
          # Get credential ID and export certificate
          SLHDSA_CRED_ID=$(ls /tmp/slhdsa-ca/credentials | head -1)
          ./qpki credential export "${SLHDSA_CRED_ID}" --cred-dir /tmp/slhdsa-ca/credentials --out /tmp/slhdsa-ca/slhdsa-cert.pem
          # Verify with qpki tool
          ./qpki cert verify /tmp/slhdsa-ca/slhdsa-cert.pem --ca /tmp/slhdsa-ca/ca.crt
          ./qpki inspect /tmp/slhdsa-ca/slhdsa-cert.pem

      - name: "[Smoke] Catalyst Hybrid"
        run: |
          # Create Catalyst hybrid CA
          ./qpki ca init --var cn="Catalyst Test CA" --ca-dir /tmp/catalyst-ca \
            --profile hybrid/catalyst/root-ca
          ./qpki ca export --ca-dir /tmp/catalyst-ca --out /tmp/catalyst-ca/ca.crt
          # Issue Catalyst certificate with dual signatures using credential enroll
          ./qpki credential enroll --ca-dir /tmp/catalyst-ca --cred-dir /tmp/catalyst-ca/credentials --profile hybrid/catalyst/tls-server \
            --var cn=catalyst.test.local --var dns_names=catalyst.test.local
          # Get credential ID and export certificate
          CATALYST_CRED_ID=$(ls /tmp/catalyst-ca/credentials | head -1)
          ./qpki credential export "${CATALYST_CRED_ID}" --cred-dir /tmp/catalyst-ca/credentials --out /tmp/catalyst-ca/catalyst-cert.pem
          # Verify both signatures with qpki tool
          ./qpki cert verify /tmp/catalyst-ca/catalyst-cert.pem --ca /tmp/catalyst-ca/ca.crt
          # Show certificate with Catalyst extensions
          ./qpki inspect /tmp/catalyst-ca/catalyst-cert.pem

      - name: "[Smoke] Composite Hybrid"
        run: |
          # Create Composite hybrid CA (IETF draft-ietf-lamps-pq-composite-sigs-13)
          ./qpki ca init --var cn="Composite Test CA" --ca-dir /tmp/composite-ca \
            --profile hybrid/composite/root-ca
          ./qpki ca export --ca-dir /tmp/composite-ca --out /tmp/composite-ca/ca.crt
          # Issue Composite certificate with single composite signature
          ./qpki credential enroll --ca-dir /tmp/composite-ca --cred-dir /tmp/composite-ca/credentials --profile hybrid/composite/tls-server \
            --var cn=composite.test.local --var dns_names=composite.test.local
          # Get credential ID and export certificate
          COMPOSITE_CRED_ID=$(ls /tmp/composite-ca/credentials | head -1)
          ./qpki credential export "${COMPOSITE_CRED_ID}" --cred-dir /tmp/composite-ca/credentials --out /tmp/composite-ca/composite-cert.pem
          # Verify both component signatures with qpki tool
          ./qpki cert verify /tmp/composite-ca/composite-cert.pem --ca /tmp/composite-ca/ca.crt
          # Show certificate info
          ./qpki inspect /tmp/composite-ca/composite-cert.pem
          ./qpki inspect /tmp/composite-ca/ca.crt

  # =============================================================================
  # Acceptance Tests (Go-based CLI black-box tests)
  # =============================================================================

  acceptance-pki:
    name: "[Acceptance] PKI Operations"
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [build]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true

      - name: Download binary
        uses: actions/download-artifact@v4
        with:
          name: qpki-ci-binary
          path: ./

      - name: Run PKI acceptance tests
        run: |
          chmod +x ./qpki
          QPKI_BINARY=$(pwd)/qpki go test -v -json -tags=acceptance -run 'TestA_(Key|CA|CSR|Cert|CRL|Credential|Profile|Inspect|E2E|CLI)' ./test/acceptance/... 2>&1 | tee test-output.json
          chmod +x scripts/ci/go-test-ctrf.sh
          TOOL_NAME=acceptance-pki ./scripts/ci/go-test-ctrf.sh < test-output.json > ctrf-acceptance-pki.json

      - name: Upload CTRF Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ctrf-acceptance-pki
          path: ctrf-acceptance-pki.json
          retention-days: 30

  acceptance-protocols:
    name: "[Acceptance] OCSP/TSA/CMS"
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [build]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true

      - name: Download binary
        uses: actions/download-artifact@v4
        with:
          name: qpki-ci-binary
          path: ./

      - name: Run protocol acceptance tests
        run: |
          chmod +x ./qpki
          QPKI_BINARY=$(pwd)/qpki go test -v -json -tags=acceptance -run 'TestA_(OCSP|TSA|CMS|COSE)' ./test/acceptance/... 2>&1 | tee test-output.json
          chmod +x scripts/ci/go-test-ctrf.sh
          TOOL_NAME=acceptance-protocols ./scripts/ci/go-test-ctrf.sh < test-output.json > ctrf-acceptance-protocols.json

      - name: Upload CTRF Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ctrf-acceptance-protocols
          path: ctrf-acceptance-protocols.json
          retention-days: 30

  acceptance-agility:
    name: "[Acceptance] Crypto-Agility"
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [build]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true

      - name: Download binary
        uses: actions/download-artifact@v4
        with:
          name: qpki-ci-binary
          path: ./

      - name: Run crypto-agility tests
        run: |
          chmod +x ./qpki
          QPKI_BINARY=$(pwd)/qpki go test -v -json -tags=acceptance -run 'TestA_Agility' ./test/acceptance/... 2>&1 | tee test-output.json
          chmod +x scripts/ci/go-test-ctrf.sh
          TOOL_NAME=acceptance-agility ./scripts/ci/go-test-ctrf.sh < test-output.json > ctrf-acceptance-agility.json

      - name: Upload CTRF Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ctrf-acceptance-agility
          path: ctrf-acceptance-agility.json
          retention-days: 30

  crosstest-openssl:
    name: "[Interop] OpenSSL 3.6"
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [build]
    steps:
      - uses: actions/checkout@v4

      - name: Download binary
        uses: actions/download-artifact@v4
        with:
          name: qpki-ci-binary
          path: ./

      - name: Make executable
        run: chmod +x ./qpki

      - name: "[Interop] Cache OpenSSL 3.6"
        id: cache-openssl
        uses: actions/cache@v4
        with:
          path: /opt/openssl-3.6
          key: openssl-3.6.0-${{ runner.os }}

      - name: "[Interop] Install OpenSSL 3.6.0"
        if: steps.cache-openssl.outputs.cache-hit != 'true'
        run: |
          wget -q https://github.com/openssl/openssl/releases/download/openssl-3.6.0/openssl-3.6.0.tar.gz
          tar xzf openssl-3.6.0.tar.gz && cd openssl-3.6.0
          ./Configure --prefix=/opt/openssl-3.6 --libdir=lib
          make -j$(nproc) && sudo make install

      - name: "[Interop] Configure OpenSSL 3.6 Path"
        run: |
          echo "/opt/openssl-3.6/bin" >> $GITHUB_PATH
          echo "LD_LIBRARY_PATH=/opt/openssl-3.6/lib" >> $GITHUB_ENV

      - name: "[Interop] Verify OpenSSL Version"
        run: |
          /opt/openssl-3.6/bin/openssl version
          /opt/openssl-3.6/bin/openssl version | grep -q "3.6"

      - name: "[Interop] Generate Test Fixtures"
        run: |
          chmod +x test/crossval/generate_qpki_fixtures.sh
          ./test/crossval/generate_qpki_fixtures.sh

      - name: "[Interop] Generate Extension Fixtures"
        run: |
          chmod +x test/crossval/generate_qpki_extension_fixtures.sh
          ./test/crossval/generate_qpki_extension_fixtures.sh

      - name: "[Interop] Run OpenSSL Tests"
        run: |
          cd test/crossval/openssl
          chmod +x *.sh
          ./run_all.sh

      # Summary is centralized in quality-report job via generate-ci-report.sh

      - name: "[Interop] Upload OpenSSL Results"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ctrf-crosstest-openssl
          path: |
            test/crossval/openssl/ctrf-crosstest-openssl.json
            test/crossval/openssl/results-openssl.json
          retention-days: 30

  crosstest-bc:
    name: "[Interop] BouncyCastle 1.83"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [build]
    steps:
      - uses: actions/checkout@v4

      - name: Download binary
        uses: actions/download-artifact@v4
        with:
          name: qpki-ci-binary
          path: ./

      - name: Make executable
        run: chmod +x ./qpki

      - name: "[Interop] Set Up Java 17"
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      - name: "[Interop] Generate Test Fixtures"
        run: |
          chmod +x test/crossval/generate_qpki_fixtures.sh
          ./test/crossval/generate_qpki_fixtures.sh

      - name: "[Interop] Generate Extension Fixtures"
        run: |
          chmod +x test/crossval/generate_qpki_extension_fixtures.sh
          ./test/crossval/generate_qpki_extension_fixtures.sh

      - name: "[Interop] Run BouncyCastle Tests"
        run: |
          cd test/crossval/bouncycastle
          mvn -q test

      - name: "[Interop] Generate BouncyCastle Summary"
        if: always()
        run: |
          cd test/crossval/bouncycastle
          chmod +x generate_summary.sh
          ./generate_summary.sh || true

      - name: "[Interop] Upload BC Results"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ctrf-crosstest-bc
          path: |
            test/crossval/bouncycastle/ctrf-crosstest-bc.json
            test/crossval/bouncycastle/results-bc.json
          retention-days: 30

  hsm-test:
    name: "[HSM] HSM Operations (SoftHSM2)"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [build]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true

      - name: "[HSM] Install SoftHSM2"
        run: sudo apt-get update && sudo apt-get install -y softhsm2

      - name: Download binary
        uses: actions/download-artifact@v4
        with:
          name: qpki-ci-binary
          path: ./

      - name: Make executable
        run: chmod +x ./qpki

      - name: "[HSM] Configure SoftHSM2"
        run: |
          mkdir -p ~/.config/softhsm2/tokens
          echo "directories.tokendir = $HOME/.config/softhsm2/tokens" > ~/.config/softhsm2/softhsm2.conf
          export SOFTHSM2_CONF=$HOME/.config/softhsm2/softhsm2.conf

      - name: "[HSM] HSM: Initialize Token"
        run: |
          export SOFTHSM2_CONF=$HOME/.config/softhsm2/softhsm2.conf
          softhsm2-util --init-token --slot 0 --label "QPKI-Test" --pin 1234 --so-pin 12345678

      - name: "[HSM] HSM: Create Config"
        run: |
          cat > /tmp/hsm-test.yaml << 'EOF'
          type: pkcs11
          pkcs11:
            lib: /usr/lib/softhsm/libsofthsm2.so
            token: "QPKI-Test"
            pin_env: HSM_PIN
          EOF

      - name: "[HSM] Run All Acceptance Tests (HSM Mode)"
        env:
          SOFTHSM2_CONF: ${{ github.workspace }}/.config/softhsm2/softhsm2.conf
          HSM_PIN: "1234"
          HSM_CONFIG: /tmp/hsm-test.yaml
          QPKI_BINARY: ${{ github.workspace }}/qpki
          TEST_HSM_MODE: "1"
        run: |
          export SOFTHSM2_CONF=$HOME/.config/softhsm2/softhsm2.conf
          go test -v -json -tags=acceptance ./test/acceptance/... 2>&1 | tee test-output.json
          chmod +x scripts/ci/go-test-ctrf.sh
          TOOL_NAME=hsm ./scripts/ci/go-test-ctrf.sh < test-output.json > ctrf-hsm.json

      - name: "[HSM] Upload CTRF Report"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ctrf-hsm
          path: ctrf-hsm.json
          retention-days: 30

  lab-tests:
    name: "[E2E] Lab Demo Tests"
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [build]
    steps:
      - uses: actions/checkout@v4

      - name: "[E2E] Checkout Lab Repo"
        uses: actions/checkout@v4
        with:
          repository: remiblancher/post-quantum-pki-lab
          ref: main
          path: lab

      - name: "[E2E] Download Binary"
        uses: actions/download-artifact@v4
        with:
          name: qpki-ci-binary
          path: lab/bin/

      - name: "[E2E] Make Executable"
        run: |
          chmod +x lab/bin/qpki
          lab/bin/qpki --version

      - name: "[E2E] Run All Lab Demos"
        env:
          CI: "true"
        run: |
          cd lab
          failed=0
          for demo in journey/*/demo.sh; do
            demo_dir=$(dirname "$demo")
            echo ""
            echo "=========================================="
            echo "Testing: $demo"
            echo "=========================================="
            if (cd "$demo_dir" && bash demo.sh); then
              echo "✓ PASSED: $demo"
            else
              echo "✗ FAILED: $demo"
              failed=$((failed + 1))
            fi
          done

          echo ""
          echo "=========================================="
          if [ $failed -eq 0 ]; then
            echo "All lab demos passed!"
          else
            echo "FAILED: $failed demo(s) failed"
            exit 1
          fi

      - name: "[E2E] Upload Demo Outputs"
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: lab-demo-outputs
          path: lab/journey/*/output/
          retention-days: 7

  security:
    name: "[Unit] Security Scan"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: "[Unit] Run Trivy Vulnerability Scanner"
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          severity: 'CRITICAL,HIGH'

  license-check:
    name: "[Unit] License Compliance"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true

      - name: "[License] Install go-licenses"
        run: go install github.com/google/go-licenses@latest

      - name: "[License] Check compliance"
        run: go-licenses check ./... --disallowed_types=forbidden,restricted

  sbom:
    name: "[Unit] Generate SBOM"
    runs-on: ubuntu-latest
    needs: [build]
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: "[SBOM] Generate SBOM (CycloneDX)"
        uses: anchore/sbom-action@v0
        with:
          format: cyclonedx-json
          output-file: sbom.cdx.json

      - name: "[SBOM] Upload artifact"
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.cdx.json
          retention-days: 30

  build-matrix:
    timeout-minutes: 15
    needs: [test, lint]
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            goos: linux
            goarch: amd64
          - os: ubuntu-24.04-arm
            goos: linux
            goarch: arm64
          - os: macos-latest
            goos: darwin
            goarch: arm64
          - os: macos-latest
            goos: darwin
            goarch: amd64
            cross: true  # Cross-compile from arm64 to amd64
          - os: windows-latest
            goos: windows
            goarch: amd64
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true

      - name: "[Build] Unix"
        if: matrix.goos != 'windows'
        env:
          CGO_ENABLED: 1
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: go build -o qpki-${{ matrix.goos }}-${{ matrix.goarch }} ./cmd/qpki

      - name: "[Build] Windows"
        if: matrix.goos == 'windows'
        env:
          CGO_ENABLED: 1
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: go build -o qpki-${{ matrix.goos }}-${{ matrix.goarch }}.exe ./cmd/qpki

      - name: "[Build] Upload Artifact"
        uses: actions/upload-artifact@v4
        with:
          name: qpki-${{ matrix.goos }}-${{ matrix.goarch }}
          path: qpki-*
          retention-days: 7

  fuzz:
    name: "[Unit] Fuzz Testing"
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [test]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true

      - name: "[Unit] Fuzz: x509util CSR/Extension Parsers"
        run: |
          go test -fuzz=FuzzParsePQCCSR -fuzztime=30s ./internal/x509util/ || true
          go test -fuzz=FuzzDecodeHybridExtension -fuzztime=30s ./internal/x509util/ || true
          go test -fuzz=FuzzParseCatalystExtensions -fuzztime=30s ./internal/x509util/ || true
          go test -fuzz=FuzzDecodeRelatedCertificate -fuzztime=30s ./internal/x509util/ || true
          go test -fuzz=FuzzReconstructTBSWithoutAltSigValue -fuzztime=30s ./internal/x509util/ || true

      - name: "[Unit] Fuzz: CA Composite Parsers"
        run: |
          go test -fuzz=FuzzParseCompositeSignatureValue -fuzztime=30s ./internal/ca/ || true
          go test -fuzz=FuzzParseCompositePublicKey -fuzztime=30s ./internal/ca/ || true
          go test -fuzz=FuzzParseMLDSA65PublicKey -fuzztime=30s ./internal/ca/ || true
          go test -fuzz=FuzzParseClassicalPublicKeyP256 -fuzztime=30s ./internal/ca/ || true

      - name: "[Unit] Fuzz: Crypto Algorithm Parsers"
        run: |
          go test -fuzz=FuzzParseAlgorithm -fuzztime=30s ./internal/crypto/ || true
          go test -fuzz=FuzzAlgorithmFromOID -fuzztime=30s ./internal/crypto/ || true
          go test -fuzz=FuzzParsePublicKeyMLDSA65 -fuzztime=30s ./internal/crypto/ || true

      - name: "[Unit] Fuzz: Profile YAML Parsers"
        run: |
          go test -fuzz=FuzzLoadProfileFromBytes -fuzztime=30s ./internal/profile/ || true
          go test -fuzz=FuzzParseDuration -fuzztime=30s ./internal/profile/ || true

      - name: "[Unit] Fuzz: Credential JSON Parsers"
        run: |
          go test -fuzz=FuzzCredentialUnmarshalJSON -fuzztime=30s ./internal/credential/ || true
          go test -fuzz=FuzzGenerateCredentialID -fuzztime=30s ./internal/credential/ || true

      - name: "[Unit] Fuzz: CMS Parsers"
        run: |
          go test -fuzz=FuzzParseSignedData -fuzztime=30s ./internal/cms/ || true
          go test -fuzz=FuzzParseEnvelopedData -fuzztime=30s ./internal/cms/ || true

      - name: "[Unit] Fuzz: TSA Parsers"
        run: |
          go test -fuzz=FuzzU_Request_Parse -fuzztime=30s ./internal/tsa/ || true
          go test -fuzz=FuzzU_Response_Parse -fuzztime=30s ./internal/tsa/ || true

      - name: "[Unit] Fuzz: OCSP Parsers"
        run: |
          go test -fuzz=FuzzU_ParseRequest -fuzztime=30s ./internal/ocsp/ || true
          go test -fuzz=FuzzU_ParseResponse -fuzztime=30s ./internal/ocsp/ || true

      - name: "[Unit] Upload Crash Artifacts"
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: fuzz-crashes
          path: |
            **/testdata/fuzz/**/
          retention-days: 30

  # ===========================================================================
  # Quality Report (consolidates all CI results)
  # ===========================================================================
  quality-report:
    name: "[Report] Quality Dashboard"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [test, acceptance-pki, acceptance-protocols, acceptance-agility,
            hsm-test, crosstest-openssl, crosstest-bc, lab-tests, fuzz]
    if: always()
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true

      - name: Download coverage artifact
        uses: actions/download-artifact@v4
        with:
          name: coverage-report
          path: ./
        continue-on-error: true

      - name: Download all CTRF artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: ctrf-*
          path: ./ctrf-results
          merge-multiple: true
        continue-on-error: true

      - name: "[Report] Merge CTRF Reports"
        run: |
          mkdir -p ./ctrf-results
          # List available CTRF files
          echo "Available CTRF files:"
          ls -la ./ctrf-results/*.json 2>/dev/null || echo "No CTRF files found"

          # Merge all CTRF files into one
          if ls ./ctrf-results/*.json 1>/dev/null 2>&1; then
            jq -s '{
              "results": {
                "tool": { "name": "qpki-ci" },
                "summary": {
                  "tests": ([.[].results.summary.tests // 0] | add),
                  "passed": ([.[].results.summary.passed // 0] | add),
                  "failed": ([.[].results.summary.failed // 0] | add),
                  "skipped": ([.[].results.summary.skipped // 0] | add),
                  "pending": 0,
                  "other": 0,
                  "start": ([.[].results.summary.start // 0] | min),
                  "stop": ([.[].results.summary.stop // 0] | max)
                },
                "suites": [.[].results | {
                  "name": .tool.name,
                  "tests": (.summary.tests // 0),
                  "passed": (.summary.passed // 0),
                  "failed": (.summary.failed // 0),
                  "skipped": (.summary.skipped // 0)
                }]
              }
            }' ./ctrf-results/*.json > ctrf-merged.json
            echo "Merged CTRF report:"
            cat ctrf-merged.json | jq '.results.summary'
          else
            echo '{"results":{"tool":{"name":"qpki-ci"},"summary":{"tests":0,"passed":0,"failed":0,"skipped":0},"suites":[]}}' > ctrf-merged.json
          fi

      - name: "[Report] Generate Quality Dashboard"
        run: |
          chmod +x scripts/ci/generate-ci-report.sh
          CTRF_FILE=ctrf-merged.json \
          COVERAGE_FILE=coverage.out \
          OUTPUT_FILE=quality-report.md \
          OPENSSL_RESULTS=./ctrf-results/results-openssl.json \
          BC_RESULTS=./ctrf-results/results-bc.json \
          ./scripts/ci/generate-ci-report.sh

      - name: "[Report] Upload Quality Report"
        uses: actions/upload-artifact@v4
        with:
          name: quality-report
          path: |
            quality-report.md
            quality-report.json
            ctrf-merged.json
          retention-days: 90

